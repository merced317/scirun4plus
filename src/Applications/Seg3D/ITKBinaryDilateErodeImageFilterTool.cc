//  
//  For more information, please see: http://software.sci.utah.edu
//  
//  The MIT License
//  
//  Copyright (c) 2009 Scientific Computing and Imaging Institute,
//  University of Utah.
//  
//  
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//  
//    File   : ITKBinaryDilateErodeImageFilterTool.cc
//    Author : David Brayford
//    Date   : May 2008

#include <Applications/Seg3D/ITKBinaryDilateErodeImageFilterTool.h>
#include <Applications/Seg3D/Seg3DFrame.h>
#include <Applications/Seg3D/VolumeOps.h>
#include <Core/Util/Assert.h>

namespace SCIRun {


ITKBinaryDilateErodeImageFilterTool::ITKBinaryDilateErodeImageFilterTool(Painter *painter)
  : BaseTool("ITKBinaryDilateErodeImageFilterTool::"),
    PointerTool("ITKBinaryDilateErodeImageFilterTool::"),
    painter_(painter)
{
}


BaseTool::propagation_state_e 
ITKBinaryDilateErodeImageFilterTool::process_event(event_handle_t event)
{
  // Check for the FinishEvent signal generated by the start button
  if (dynamic_cast<DilateEvent *>(event.get_rep()))
  {
    if (!painter_->check_for_active_label_volume("Binary dilate"))
    {
      return STOP_E;
    }
    painter_->set_status("Dilating " + painter_->current_volume_->name_ + ".");
    painter_->start_progress();
    if( !run_dilate_filter() )
    {
      return STOP_E;
    }
    painter_->finish_progress();
    painter_->extract_all_window_slices();
    painter_->redraw_all();
  }
  else if (dynamic_cast<ErodeEvent *>(event.get_rep()))
  {
    if (!painter_->check_for_active_label_volume("Binary erode"))
    {
      return STOP_E;
    }
    painter_->set_status("Eroding " + painter_->current_volume_->name_ + ".");
    painter_->start_progress();
    if( !run_erode_filter() )
    {
      return STOP_E;
    }
    painter_->finish_progress();
    painter_->extract_all_window_slices();
    painter_->redraw_all();
  }
  else if (dynamic_cast<DilateErodeEvent *>(event.get_rep()))
  {
    if (!painter_->check_for_active_label_volume("Binary dilate/erode"))
    {
      return STOP_E;
    }
    painter_->set_status("Dilating and then eroding " +
			 painter_->current_volume_->name_ + ".");
    painter_->start_progress();
    if( !run_dilate_erode_filter() )
    {
      return STOP_E;
    }
    painter_->finish_progress();
    painter_->extract_all_window_slices();
    painter_->redraw_all();
  }

  return CONTINUE_E;
}


NrrdVolumeHandle
ITKBinaryDilateErodeImageFilterTool::make_tmp_volume()
{
  // Make a temporary volume with only the one bit plane in it for ITK.
  NrrdDataHandle nrrdh =
    VolumeOps::create_clear_nrrd(painter_->current_volume_->nrrd_handle_,
                                 LabelNrrdType);

  NrrdVolumeHandle srcdst = new NrrdVolume(painter_, "Unused", nrrdh, 1);

  VolumeOps::bit_copy(srcdst->nrrd_handle_, 1,
                      painter_->current_volume_->nrrd_handle_,
                      painter_->current_volume_->label_);

  return srcdst;
}


bool
ITKBinaryDilateErodeImageFilterTool::run_dilate_filter()
{
  // Make a temporary volume with only the one bit plane in it for ITK.
  NrrdVolumeHandle srcdst = make_tmp_volume();

  // Run the dilate filter.
  if( !run_dilate_filter(srcdst) )
    return false;
  
  // Push the undo object for this operation.
  NrrdVolumeHandle vol = painter_->current_volume_;
  NrrdDataHandle volnrrd = vol->nrrd_handle_->clone();
  UndoHandle undo =
    new UndoReplaceVolume(painter_, "Undo Dilate", vol, volnrrd);
  painter_->push_undo(undo);

  // Put the results back from the temporary copy.
  VolumeOps::bit_copy(painter_->current_volume_->nrrd_handle_,
                      painter_->current_volume_->label_,
                      srcdst->nrrd_handle_, 1);

  return true;
}


bool
ITKBinaryDilateErodeImageFilterTool::run_erode_filter()
{
  // Make a temporary volume with only the one bit plane in it for ITK.
  NrrdVolumeHandle srcdst = make_tmp_volume();

  // Run the erode filter.
  if( !run_erode_filter(srcdst) )
    return false;

  // Push the undo object for this operation.
  NrrdVolumeHandle vol = painter_->current_volume_;
  NrrdDataHandle volnrrd = vol->nrrd_handle_->clone();
  UndoHandle undo =
    new UndoReplaceVolume(painter_, "Undo Erode", vol, volnrrd);
  painter_->push_undo(undo);

  // Put the results back from the temporary copy.
  VolumeOps::bit_copy(painter_->current_volume_->nrrd_handle_,
                      painter_->current_volume_->label_,
                      srcdst->nrrd_handle_, 1);

  return true;
}


bool
ITKBinaryDilateErodeImageFilterTool::run_dilate_erode_filter()
{
  // Make a temporary volume with only the one bit plane in it for ITK.
  NrrdVolumeHandle srcdst = make_tmp_volume();

  // Run the dilate filter.
  if( !run_dilate_filter(srcdst) )
    return false;

  // Run the erode filter
  if( !run_erode_filter(srcdst) )
    return false;

  // Push the undo object for this operation.
  NrrdVolumeHandle vol = painter_->current_volume_;
  NrrdDataHandle volnrrd = vol->nrrd_handle_->clone();
  UndoHandle undo =
    new UndoReplaceVolume(painter_, "Undo Dilate->Erode", vol, volnrrd);
  painter_->push_undo(undo);

  // Put the results back from the temporary copy.
  VolumeOps::bit_copy(painter_->current_volume_->nrrd_handle_,
                      painter_->current_volume_->label_,
                      srcdst->nrrd_handle_, 1);

  return true;
}


bool
ITKBinaryDilateErodeImageFilterTool::run_dilate_filter(NrrdVolumeHandle srcdst)
{
  // Run the dilate filter.
  const string name = "ITKBinaryDilateErodeImageFilterTool::";
  structuringElement_.SetRadius(painter_->get_vars()->get_int(name+"DilateRadius"));
  structuringElement_.CreateStructuringElement();
  
  dilate_filter_->SetKernel(structuringElement_);
  dilate_filter_->SetDilateValue(1);

  if( atoi(painter_->get_vars()->get_string(name+"Dimension").c_str()) == 2 )
  {
    unsigned int ndims = srcdst->nrrd_handle_->nrrd_->dim;
    unsigned int nslices = srcdst->nrrd_handle_->nrrd_->axis[ndims-1].size;

    int slab_size =
      VolumeOps::nrrd_data_size( srcdst->nrrd_handle_ ) / nslices;

    // Pointer to the source/destination data.
    unsigned char * data_ptr =
      (unsigned char *) (srcdst->nrrd_handle_->nrrd_->data);

    // Manage the progress bar within.
    dilate_filter_.show_progress(false);
      
    // Operate on a slice by slice basis.
    for( size_t i=0; i<nslices; ++i )
    {
      Nrrd *nin = srcdst->nrrd_handle_->nrrd_;
      Nrrd *nout = nrrdNew();
  
      // Get a temporary slice to work on.
      if( nrrdSlice(nout, nin, ndims-1, i) )
      {
	char *err = biffGetDone(NRRD);
	painter_->set_status( string("Arithmetic tool error performing nrrd operation failed: ") + err);
	free(err);

	cerr << string("Error on line #") 
	     << to_string(__LINE__)
	     << string(" executing nrrd command: nrrdSlice \n")
	     << string("Message: ") 
	     << err
	     << std::endl;

	return false;
      }

      NrrdDataHandle nrrd_data_handle(new NrrdData(nout));

      NrrdVolumeHandle tmpdst =
	new NrrdVolume(painter_, "Unused", nrrd_data_handle, 1);

      dilate_filter_.set_volume(tmpdst);
      dilate_filter_();

      // Copy the temporary slice into the original destination.
      memcpy( data_ptr + i*slab_size,
	      tmpdst->nrrd_handle_->nrrd_->data, slab_size );

      // Manage the progress bar within.
      const int progress = (int)((float) i / (float) nslices * 100.0);

      painter_->update_progress(progress);
    }
  }
  else
  {
    dilate_filter_.show_progress(true);
    dilate_filter_.set_volume(srcdst);
    dilate_filter_();
  }

  return true;
}


bool
ITKBinaryDilateErodeImageFilterTool::run_erode_filter(NrrdVolumeHandle srcdst)
{
  // Run the erode filter.
  const string name = "ITKBinaryDilateErodeImageFilterTool::";
  structuringElement_.SetRadius(painter_->get_vars()->get_int(name+"ErodeRadius"));
  structuringElement_.CreateStructuringElement();
  
  erode_filter_->SetKernel(structuringElement_);
  erode_filter_->SetErodeValue(1);

  if( atoi(painter_->get_vars()->get_string(name+"Dimension").c_str()) == 2 )
  {
    unsigned int ndims = srcdst->nrrd_handle_->nrrd_->dim;
    unsigned int nslices = srcdst->nrrd_handle_->nrrd_->axis[ndims-1].size;

    int slab_size =
      VolumeOps::nrrd_data_size( srcdst->nrrd_handle_ ) / nslices;

    // Pointer to the source/destination data.
    unsigned char * data_ptr =
      (unsigned char *) (srcdst->nrrd_handle_->nrrd_->data);

    // Manage the progress bar within.
    erode_filter_.show_progress(false);
      
    // Operate on a slice by slice basis.
    for( size_t i=0; i<nslices; ++i )
    {
      Nrrd *nin = srcdst->nrrd_handle_->nrrd_;
      Nrrd *nout = nrrdNew();
  
      // Get a temporary slice to work on.
      if( nrrdSlice(nout, nin, ndims-1, i) )
      {
	char *err = biffGetDone(NRRD);
	painter_->set_status( string("Arithmetic tool error performing nrrd operation failed: ") + err);
	free(err);

	cerr << string("Error on line #") 
	     << to_string(__LINE__)
	     << string(" executing nrrd command: nrrdSlice \n")
	     << string("Message: ") 
	     << err
	     << std::endl;

	return false;
      }

      NrrdDataHandle nrrd_data_handle(new NrrdData(nout));

      NrrdVolumeHandle tmpdst =
	new NrrdVolume(painter_, "Unused", nrrd_data_handle, 1);

      erode_filter_.set_volume(tmpdst);

      erode_filter_();

      // Copy the temporary slice into the original destination.
      memcpy( data_ptr + i*slab_size,
	      tmpdst->nrrd_handle_->nrrd_->data, slab_size );

      // Manage the progress bar within.
      const int progress = (int)((float) i / (float) nslices * 100.0);

      painter_->update_progress(progress);
    }
  }
  else
  {
    erode_filter_.show_progress(true);
    erode_filter_.set_volume(srcdst);
    erode_filter_();
  }

  return true;
}


}
